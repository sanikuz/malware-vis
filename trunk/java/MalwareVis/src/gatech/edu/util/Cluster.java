package gatech.edu.util;

import java.util.ArrayList;
import java.util.HashSet;
import gatech.edu.pcap.*;

import weka.core.*;
import weka.clusterers.XMeans;
import weka.filters.unsupervised.attribute.AddCluster;
import weka.filters.Filter;

public class Cluster {

   /**
    * Attributes.
    *
    * * Total size
    * * Total duration
    * * Number of packets
    * * Number of domain names
    * * Number of IP addresses
    * * Number of country codes
    *
    */
   private static Instances makeInstances(ArrayList<Pcap> pcaps) {
      // Set up attributes
      FastVector atts = new FastVector();
      atts.addElement(new Attribute("size"));
      atts.addElement(new Attribute("duration"));
      atts.addElement(new Attribute("numpackets"));
      atts.addElement(new Attribute("numdomains"));
      atts.addElement(new Attribute("numips"));
      atts.addElement(new Attribute("numccs"));

      Instances data = new Instances("cs7450", atts, 0);
      double[] vals;

      for (Pcap pcap : pcaps) {
         Instance i = new DenseInstance(6);
         TCPStream tcp;
         long tSize = 0;
         double tDuration = pcap.getDuration();
         int numPackets = 0;
         int numDomains = 0;
         int numIPs = 0;

         HashSet<String> countryCodes = new HashSet<String>();
         for (Stream s : pcap.getStreams()) {
            tSize += s.getSize();
            numPackets += s.getNumPackets();

            if (s instanceof DNSStream) {
               numDomains += 1;
            } else if (s instanceof TCPStream) {
               numIPs += 1;
               tcp = (TCPStream) s;
               countryCodes.add(CountryLookup.getInstance().getCountryFromIP(tcp.getSrcIP()));
               countryCodes.add(CountryLookup.getInstance().getCountryFromIP(tcp.getDstIP()));
            }
         }

         // Create feature vector
         vals = new double[data.numAttributes()];
         vals[0] = tSize;
         vals[1] = tDuration;
         vals[2] = numPackets;
         vals[3] = numDomains;
         vals[4] = numIPs;
         vals[5] = countryCodes.size();

         data.add(new DenseInstance(1.0, vals));
      }

      return data;
   }

   /**
    * Generate cluster assignments for a list of pcap objects.
    *
    * @pcaps ArrayList of pcaps you want to cluster.
    */
   public static void performClustering(ArrayList<Pcap> pcaps) {
      try {
         // Get instances and initialize clusterer
         Instances data = makeInstances(pcaps);
         Instances filteredData;
         XMeans clusterer = new XMeans();
         clusterer.setMaxIterations(10);
         clusterer.setMaxKMeans(10);
         clusterer.setMinNumClusters(2);
         clusterer.setMaxNumClusters(data.size());

         // Build AddCluster filter
         AddCluster ac = new AddCluster();
         ac.setClusterer(clusterer);
         ac.setInputFormat(data);

         // Cluster and filter
         filteredData = Filter.useFilter(data, ac);
         System.out.println(filteredData);

         Instance inst;
         String clusterAssignment;
         // Update pcaps with cluster values
         for (int i = 0; i < pcaps.size(); ++i) {
            inst = filteredData.get(i);
            clusterAssignment = inst.toString(inst.attribute(inst.numAttributes() - 1));
            pcaps.get(i).setCluster(Integer.parseInt(clusterAssignment.substring("cluster".length())));
         }
      } catch (Exception e) {
         System.err.println("Clustering failed!");
         e.printStackTrace();
      }
   }

   public static void main(String[] args) {
      Pcaps ps = new Pcaps("code/testpcaps");
      performClustering(ps.getPcapList());
      for (Pcap p : ps.getPcapList()) {
         System.out.println("Cluster assignment: " + p.getCluster());
      }
   }
}
