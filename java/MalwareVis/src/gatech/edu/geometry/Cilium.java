package gatech.edu.geometry;
import processing.core.*;

public class Cilium {
	//PApplet pa; 
	//principle parameters 
	pt contact; 
	float angle; 
	float[] leng;
	float span; 
	float width; 
	String text; 
	String imgpath = null; 
	boolean mask; 
	boolean type; //true DNS Stream, false TCP Stream
	//assistant parameters 
	float div=PApplet.log(133.0f); 
	float space = 20f;
	float height = 20; 

	public Cilium(){ 
	}
	public void setText(String t){
		text = t; 
	}
	
	public void setImagePath(String path){
		imgpath = path; 
	}
	
	public void computeAngleAndContact(double start_time, double end_time, double duration, Cell cell){
		angle = ((float)start_time+(float)end_time)/(float)duration*11/12*PConstants.PI+ PConstants.PI/12;
		float cx = cell.center.x-cell.radius*PApplet.sin(angle);
		float cy = cell.center.y+cell.radius*PApplet.cos(angle); 
		contact = new pt(cx, cy); 
	}
	
	public void computeContact(float angle, Cell cell){
		this.angle=angle;
		float cx = cell.center.x-cell.radius*PApplet.sin(angle);
		float cy = cell.center.y+cell.radius*PApplet.cos(angle); 
		contact = new pt(cx, cy); 
	}
	
	public void setSpan(double start_time, double end_time, Cell cell){
		float h_max = cell.radius*0.2f; 
		float h_min = cell.radius*0.04f; 
		float d = (float) (end_time-start_time); 
		span = (h_max-(h_max-h_min)/(d+1)); 
	}
	public void setLeng(long l, float l_min, float l_max){
		int num = (int)l;
		leng = new float[num];
		float r = (l_max-l_min)/l_max; 
		float ls = l_min; 
		for(int i=0; i<num; i++){
			leng[i]= ls; 
			ls*=r; 
		}
	}
	public void setMask(boolean m){
		mask = m; 
	}
	public void setType(boolean t){
		type = t; 
	}
	public void setWidth(long size, Cell cell){
		float w_max = cell.radius*2; 
		float w_min = cell.radius*0.04f; 
		float d = PApplet.log(size)/div;
		width = w_max - (w_max - w_min)/(d+0.02f); 
		//if (size == 133) System.out.println("width: "+width+", wmin: "+w_min); 
	}
	//display
	public float disTo(pt m){
		//TODO compute more precise selection based on l_max, l_min, angle contact
		return m.disTo(contact); 
	}
	public void drawCiliumNoColor(PApplet pa){
		pa.noFill(); 
		pa.pushMatrix(); 
		pa.translate(contact.x, contact.y); 
		pa.rotate(angle-PConstants.PI);
		float y = drawSegments(pa);
		if (mask){
			if (type) color.fill(color.darkBlue, pa); 
			else color.fill(color.darkGreen, pa); 
		}
		else color.fill(color.lightGray, pa); 
		pa.ellipse(0, y, width, height); 
		pa.popMatrix();
	}
	public void drawCilium(PApplet pa){
		if (type) color.stroke(color.darkBlue, pa); 
		else color.stroke(color.darkGreen, pa); 
		drawCiliumNoColor(pa); 
	}
	private float drawSegments(PApplet pa){
		float y = 0; 
		pa.beginShape(PConstants.QUAD_STRIP); 
		pa.vertex(-span, 0); 
		pa.vertex(span, 0); 
		for (int i=0; i<leng.length; i++){
			y-=leng[i];
			pa.vertex(-span, y);
			pa.vertex(span, y);  
		}
		pa.endShape(); 
		y-=height/2; 
		return y; 
	}
	
	public void draw(PApplet pa){
		pa.strokeWeight(1); 
		drawCilium(pa); 
		
	}
	public void drawSelected(PApplet pa){
		pa.strokeWeight(2);
		color.stroke(color.lightPink, pa); 
		drawCiliumNoColor(pa); 
	}
}