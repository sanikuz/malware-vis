package gatech.edu;
import gatech.edu.frame.listener.AlphaSliderListener;
import gatech.edu.frame.listener.TableFilterListener;
import gatech.edu.frame.listener.TableRowListener;
import gatech.edu.frame.listener.TimeSliderListener;
import gatech.edu.frame.listener.ViewControlListener;
import gatech.edu.pcap.*; 
import gatech.edu.util.SliderPane;

import java.awt.*; 
import java.util.ArrayList;
import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.JInternalFrame;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.JTextField;
import javax.swing.ListSelectionModel;
import javax.swing.RowFilter;
import javax.swing.event.TableModelEvent;
import javax.swing.event.TableModelListener;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.TableRowSorter;

public class TableFrame extends JInternalFrame {
	//table of pcaps
	MyTableModel pcapTableModel; 
	Object[][] pcapTableData; 
	public JTable pcapTable; 
	int num_pcap_table_cols = 7; 
	int num_pcaps; 
	public Pcaps pcaps; 
	public ArrayList<Pcap> pcap_list; 
	//table of streams
	MyTableModel streamTableModel; 
	Object[][] streamTableData; 
	JTable streamTable; 
	int num_stream_table_cols = 8; 
	int num_streams; 
	//
	public Window window; 
	Pcap selected; 
	double totalTime = 0;
	protected int frameid;
	static final int xoffset = 5, yoffset = 15;
	JTextField filtertxt;
	public SliderPane alphaPane; 
	public SliderPane timePane;
	private TableRowSorter<MyTableModel> sorter;

	public TableFrame(Pcaps pcaps, Window w){
		super("Browse Files",
	              false, //resizable
	              false, //closable
	              false, //maximizable
	              true);//iconifiable
		setSize(600,520);
		setLocation(xoffset, yoffset);
		this.setLayout(new GridBagLayout()); 
		this.window = w; 
		this.pcaps = pcaps;
		pcap_list = pcaps.getPcapList();
		pcapTableModel = new MyTableModel(pcap_list);
		selected = pcap_list.get(0); 
		streamTableModel = new MyTableModel(selected); 
		init();
	}
	private void init(){
		JPanel FilterPanel = initFilters(); 
		GridBagConstraints c = new GridBagConstraints(); 
		c.fill=GridBagConstraints.HORIZONTAL;
		c.gridx = 0;     
		c.gridy = 0; 
		c.ipady=30; 
		c.weightx = 1; 
		add(FilterPanel, c); 
		//JPanel pcapPanel = new JPanel(); 
		pcapTable = new JTable(pcapTableModel);
		pcapTable.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION); 
		ListSelectionModel lsm = pcapTable.getSelectionModel();
        lsm.addListSelectionListener(new TableRowListener(this)); 
		JScrollPane pcapPane = new JScrollPane(pcapTable);
		pcapPane.setBorder(BorderFactory.createTitledBorder("Pcap Table"));
		c.gridy =1; 
		c.ipady=120; 
		add(pcapPane, c);
		streamTable = new JTable(streamTableModel);
		JScrollPane streamPane = new JScrollPane(streamTable); 
		streamPane.setBorder(BorderFactory.createTitledBorder("Stream Table"));
		c.gridy =2; 
		c.ipady=180; 
		add(streamPane, c); 
		sorter = new TableRowSorter<MyTableModel>(pcapTableModel);
		pcapTable.setRowSorter(sorter); 
	}
	public int getId(){
		return this.frameid;
	}
	public ArrayList<Pcap> getPcaps(){
		return pcap_list;
	}
	
	public void updateStreamTable(int rid){
		if (rid>=0 && rid <pcaps.size()) selected = pcap_list.get(rid); 
		streamTableData = parse_pcap(selected); 
		streamTableModel.setTableData(streamTableData); 
	}
	
	private Object[][] parse_pcaps(ArrayList<Pcap> inpcaps){
		Object[][] tabdata = new Object[inpcaps.size()][num_pcap_table_cols]; 
		int i=0; 
		for(Pcap pcap:inpcaps){
			tabdata[i++] = parse_digest(pcap); 
		}
		return tabdata; 
	}
	
	private Object[][] parse_pcap(Pcap selected_pcap){
		ArrayList<Stream> streams = selected_pcap.getStreams(); 
		Object[][] tabdata = new Object[streams.size()][num_stream_table_cols];
		int i=0; 
		for(Stream stream:streams){
			tabdata[i++] = parse_stream(stream); 
		}
		return tabdata;
	}
	
	private Object[] parse_digest(Pcap pcap){
		Object[] data = new Object[num_pcap_table_cols];
		Digest digest = pcap.getDigest(); 
		String name = digest.getName(); 
		long numPackets = digest.getTotNumPackets();
		long size = digest.getTotSize();
		long num = digest.getNumStreams(); 
		long numDNS = digest.getNumDNSStreams(); 
		long numTCP = digest.getNumTCPSteams(); 
		double duration = digest.getDuration(); 
		if (totalTime <duration) totalTime = duration; 
		data[0] = name; 
		data[1] = numPackets; 
		data[2] = size; 
		data[3] = num; 
		data[4] = numDNS; 
		data[5] = numTCP;
		data[6] = new Double(duration); 
		return data;
	}

	private Object[] parse_stream(Stream stream){
		Object[] data = new Object[num_stream_table_cols];
		long numPackets = stream.getNumPackets();
		double starttime = stream.getStartTime();
		/*if(starttime < min_start_time)
			min_start_time = starttime;*/
		double endtime = stream.getEndTime();
		/*if(endtime > max_end_time)
			max_end_time = endtime;*/
		long size = stream.getSize();
		boolean finished = stream.getFinished();
		boolean successful = stream.getSuccessful();
		data[2] = new Double(starttime); 
		data[3] = new Double(endtime); 
		data[4] = new Long(numPackets); 
		data[5] = new Long(size); 
		data[6] = new Boolean(finished); 
		data[7] = new Boolean(successful); 
		if(stream instanceof DNSStream){
			parse_dnsstream((DNSStream)stream, data); 
		}
		else if (stream instanceof TCPStream){
			parse_tcpstream((TCPStream)stream, data); 
		}
		else System.out.println("error: unknown stream type!"); 
		return data;
	}
	
	private static void parse_dnsstream(DNSStream stream, Object[] output){
		String domainname = stream.getDomainName();
		//ArrayList<String> ips = stream.getIPs();
		output[1] = domainname; 
		output[0] = ""; 
	}
	
	private static void parse_tcpstream(TCPStream stream, Object[] output){
		//String srcIP = stream.getSrcIP();
		String dstIP = stream.getDstIP();
		output[0] = dstIP; 
		output[1] = ""; 
	}

	public void filterTxt() {
		RowFilter<MyTableModel, Object> rf = null;
		// If current expression doesn't parse, don't update.
		try {
			//System.out.println("set row filter"); 
			rf = RowFilter.regexFilter(filtertxt.getText(), 0);
		} catch (java.util.regex.PatternSyntaxException e) {
			e.printStackTrace(); 
			return;
		}
		sorter.setRowFilter(rf);
	}
	public void filterValue(){
		 RowFilter<MyTableModel,Integer> valueFilter = new RowFilter<MyTableModel,Integer>() {
			   @Override
			public boolean include(Entry<? extends MyTableModel, ? extends Integer> entry) {
			     MyTableModel tm = entry.getModel();
			     if (((Double)entry.getValue(6)).floatValue() < timePane.getParameter()) return true;
			     return false;
			   }
			 };
		sorter.setRowFilter(valueFilter);
	}
	public class MyTableModel extends AbstractTableModel implements TableModelListener {
		private String[] stream_col_names = {"Dest IP","Domain Name","Start Time","End Time","# of Packets", "Size","Status","Successful"};
		private String[] pcap_col_names = {"MD5", "# of Packets", "Size", "# of Streams", "# of DNS Streams", "# of TCP Streams", "Duration"}; 
		private String[] col_names; 
		private Object[][]data;
		public MyTableModel(Object input){
			if (input instanceof ArrayList<?>) {
				col_names = pcap_col_names; 
				data = parse_pcaps((ArrayList<Pcap>)input); 
			}
			else if (input instanceof Pcap){
				col_names = stream_col_names; 
				data = parse_pcap((Pcap)input); 
			}
		}; 
		@Override
		public int getColumnCount(){ return col_names.length; }
		@Override
		public String getColumnName(int col) { return col_names[col]; }
		@Override
		public int getRowCount(){ return data.length; }
		@Override
		public Object getValueAt(int row, int col){ return data[row][col]; }
		@Override
		public void tableChanged(TableModelEvent e) { System.out.println(e);}
		public void setTableData(Object[][] newdata) {
			//System.out.println("set new data"); 
			data = newdata; 
			fireTableDataChanged();  
			}
		@Override
		public Class getColumnClass(int c) {
	        return getValueAt(0, c).getClass();
	        }
	}
	
	private JPanel initFilters(){
		JPanel northPanel = new JPanel(new BorderLayout());
		JPanel filter = new JPanel(new GridLayout(2, 1));
		JPanel filtertext = new JPanel(); 
		filtertext.setBorder(BorderFactory.createTitledBorder("Filter MD5"));
		filtertxt = new JTextField(20);
		filtertext.add(filtertxt);
		JButton button = new JButton("Lookup");
		button.addActionListener(new TableFilterListener(this)); 
		filtertext.add(button);
		filter.add(filtertext); 
		timePane = new SliderPane("Filter Duration", "Duration: ", 0, (int)totalTime, (int)totalTime, false);
		timePane.addListener(new TimeSliderListener(this)); 
		filter.add(timePane); 
		northPanel.add(filter, BorderLayout.WEST);
		JPanel addfilters = new JPanel(new BorderLayout());
		addfilters.setBorder(BorderFactory.createTitledBorder("Cell View Control Panel"));
		JPanel view = new JPanel(new GridLayout(1, 2)); 
		JButton single = new JButton("single");
		single.addActionListener(new ViewControlListener(this)); 
		view.add(single);
		JButton multiple = new JButton("multiple");
		view.add(multiple);
		multiple.addActionListener(new ViewControlListener(this)); 
		addfilters.add(view, BorderLayout.NORTH); 
		alphaPane = new SliderPane("Change alpha", "alpha value: ", 0, 100, 50, true); 
		alphaPane.addListener(new AlphaSliderListener(this));
		addfilters.add(alphaPane, BorderLayout.SOUTH);
		northPanel.add(addfilters, BorderLayout.EAST);
		return northPanel; 
	}
	
}
