#!/usr/bin/env jython
#
# Jython pcap parser (since dpkt is good and Jpcap blows).
#

import sys
from optparse import OptionParser
import socket
import gatech.edu.pcap.DNSStream as JavaDNSStream
import gatech.edu.pcap.Stream as JavaStream
import gatech.edu.pcap.TCPStream as JavaTCPStream
import java
import java.util.ArrayList as ArrayList

sys.path.append('libs')
import dpkt
from dpkt.pcap import Reader
from dpkt.ethernet import Ethernet

class Stream(object):
    """docstring for Stream"""
    def __init__(self, ts, pkt):
        super(Stream, self).__init__()
        self.numpackets = 0
        self.size = 0
        self.starttime = ts
        self.endtime = ts
        self.finished = False
        self.successful = False
        self.proto = type(pkt)

    def addpacket(self, ts, pkt):
        self.numpackets += 1
        self.size += len(pkt)
        self.endtime = ts

    def streammember(self, pkt):
        """Does packet 'pkt' belong to the current stream?"""
        if self.proto != type(pkt):
            return False

        return not self.finished

    def finish(self):
        """Set to finished"""
        self.finished = True

    def __tojava__(self):
        return JavaStream(self.numpackets, self.size, self.starttime, self.endtime,
                self.finished, self.successful)

    def __repr__(self):
        return 'Stream: %d sec duration, %d packets, %d bytes, finished: %s, successful: %s' \
                % (self.endtime - self.starttime, self.numpackets, self.size,
                   self.finished, self.successful)

class DNSStream(Stream):
    """docstring for Stream"""
    def __init__(self, ts, pkt):
        super(DNSStream, self).__init__(ts, pkt)
        # We assume only one query for DNS packet (reasonable)
        self.domain = pkt.qd[0].name
        self.ips = []

    def addpacket(self, ts, dns):
        super(DNSStream, self).addpacket(ts, dns)
        if dns.qr == dpkt.dns.DNS_Q:
            return
        if dns.rcode == dpkt.dns.DNS_RCODE_NOERR:
            for answer in dns.an:
                try: self.ips.append(socket.inet_ntoa(answer.rdata))
                except socket.error: pass
            self.successful = True
            self.finished = True
        elif dns.rcode == dpkt.dns.DNS_RCODE_NXDOMAIN:
            self.successful = False
            self.finished = True

    def streammember(self, pkt):
        return super(DNSStream, self).streammember(pkt) and pkt.qd[0].name == self.domain

    def __repr__(self):
        dnsrepr = 'DNSStream: domain: %s, ips: %s\n\--' \
                % (self.domain, map(str, self.ips))

        return dnsrepr + super(DNSStream, self).__repr__()

    def __tojava__(self):
        return JavaDNSStream(self.numpackets, self.size, self.starttime, self.endtime,
                self.finished, self.successful, self.domain, ArrayList(self.ips))

def getsrcdst(pkt): return socket.inet_ntoa(pkt.src), socket.inet_ntoa(pkt.dst)

class TCPStream(Stream):
    """docstring for Stream"""
    def __init__(self, ts, pkt):
        super(TCPStream, self).__init__(ts, pkt)
        self.src, self.dst = getsrcdst(pkt)
        self.sawFINACK = False

    def streammember(self, pkt):
        """Stream must be: open, have the same endpoint IPs and be a TCP
        packet to belong to an instance of TCPStream."""
        return super(TCPStream, self).streammember(pkt) and \
                set((self.src, self.dst)) == set(getsrcdst(pkt)) and \
                type(pkt.data) == dpkt.tcp.TCP

    def addpacket(self, ts, pkt):
        # Terminate stream IFF src sends [FIN, ACK]
        super(TCPStream, self).addpacket(ts, pkt)
        tcp = pkt.data
        if tcp.flags == dpkt.tcp.TH_FIN | dpkt.tcp.TH_ACK:
            # We know it's successful at this point because the client thinks
            # it has all the information. However, we can't know for sure that
            # the stream is finished because of out-of-order packets. Just
            # close all TCP streams at the end.
            self.successful = True
            self.sawFINACK = True

    def finish(self):
        self.finished = self.sawFINACK

    def __repr__(self):
        tcprepr = 'TCPStream: srcip: %s, dstip: %s\n\--' \
                % (self.src, self.dst)

        return tcprepr + super(TCPStream, self).__repr__()

    def __tojava__(self):
        return JavaTCPStream(self.numpackets, self.size, self.starttime, self.endtime,
                self.finished, self.successful, self.src, self.dst)

class ICMPStream(Stream):
    """docstring for Stream"""
    def __init__(self, ts, pkt):
        super(ICMPStream, self).__init__(ts, pkt)

dpkttostream = {
    dpkt.icmp.ICMP: ICMPStream,
    dpkt.ip.IP: TCPStream,
    dpkt.dns.DNS: DNSStream,
}

def findormake_stream(streams, ts, pkt):
    for stream in streams:
        if stream.streammember(pkt):
            return stream

    newstream = dpkttostream[type(pkt)](ts, pkt)
    streams.append(newstream)

    return newstream

def getstreams(pcapfile):
    streams = []

    # Open pcap, read/parse everything into streams, return
    # list of streams to Java.
    try:
        pcap = Reader(file(pcapfile, 'rb'))
        for ts, data in pcap:
            eth = Ethernet(data)
            ip = eth.data

            if type(ip) == dpkt.icmp.ICMP:
                stream = findormake_stream(streams, ts, ip)
                stream.addpacket(ts, ip)
            elif type(ip) == dpkt.ip.IP:
                trans = ip.data
                if type(trans) == dpkt.tcp.TCP:
                    stream = findormake_stream(streams, ts, ip)
                    stream.addpacket(ts, ip)
                elif type(trans) == dpkt.udp.UDP:
                    if trans.sport == 53 or trans.dport == 53:
                        dns = dpkt.dns.DNS(trans.data)
                        stream = findormake_stream(streams, ts, dns)
                        stream.addpacket(ts, dns)

    except dpkt.dpkt.NeedData:
        sys.stderr.write('Premature packet trace end, nothing to worry about here\n')

    javastreams = []
    for stream in streams:
        stream.finish()
        javastreams.append(stream.__tojava__())

    return ArrayList(javastreams)

def main():
    """main function for standalone usage"""
    usage = "usage: %prog [options] pcap"
    parser = OptionParser(usage=usage)

    (options, args) = parser.parse_args()

    if len(args) != 1:
        parser.print_help()
        return 2

    streams = getstreams(args[0])
    for stream in streams:
        print(stream)
        print('')

if __name__ == '__main__':
    sys.exit(main())
